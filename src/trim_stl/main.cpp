#include <string>
#include <getopt.h>
#include <cassert>
#include <iostream>
#include <fstream>
#include <vector>

static void ParseArgs(std::string *input_path, std::string *output_path, int32_t argc, char **argv) {
  int32_t c;

  // suppress automatic error messages generated by getopt
  opterr = 0;

  while ((c = getopt(argc, argv, "i:o:")) != -1) {
    switch (c) {
    case 'i':
      *input_path = optarg;
      break;
    case 'o':
      *output_path = optarg;
      break;
    case '?':
      // unrecognized option OR missing option argument
      switch (optopt) {
      case 'i':
      case 'o':
        fprintf(stderr, "Option -%c requires an argument.\n", optopt);
        break;
      default:
        if (isprint(optopt)) {
          fprintf(stderr, "Unknown option -%c\n", optopt);
        }
        else {
          fprintf(stderr, "Unknown option character \\x%x\n", optopt);
        }
        break;
      }
      exit(1);
      break;
    default:
      // My understand is getopt will return ? for all unrecognized options,
      // so I'm not sure what other cases will be caught here. Perhaps just
      // options specified in optstring that I forget to handle above...
      fprintf(stderr, "Unexpected getopt result: %c\n", optopt);
      exit(1);
      break;
    }
  }

  // should be no parameters left
  if (optind < argc) {
    fprintf(stderr, "Extraneous arguments\n");
    exit(1);
  }
}

struct stl_triangle {
  float normal[3];
  float vertex1[3];
  float vertex2[3];
  float vertex3[3];
  uint16_t dummy;
};
#define NUM_STL_TRIANGLE_BYTES (4*3*4 + 2)
//static_assert(sizeof(stl_triangle) == 4*3*4 + 2);

static void TrimTriangles(const std::string input_path, const std::string output_path) {
  // read input
  std::ifstream input(input_path, std::ios::in | std::ios::binary);
  if (!input.is_open()) {
    fprintf(stderr, "Failed to open input.\n");
    std::exit(1);
  }

  // read header
  char header[80];
  input.read(header, 80);
  if (!input) {
    fprintf(stderr, "Error reading header.\n");
    std::exit(1);
  }

  uint32_t num_triangles_in;
  input.read(reinterpret_cast<char*>(&num_triangles_in), 4);
  if (!input) {
    fprintf(stderr, "Error reading num triangles.\n");
    std::exit(1);
  }

  std::vector<stl_triangle> triangle_data;
  for (uint32_t k = 0; k < num_triangles_in; k++) {
    stl_triangle triangle;
    input.read(reinterpret_cast<char*>(&triangle), NUM_STL_TRIANGLE_BYTES);
    if (!input) {
      fprintf(stderr, "Error reading triangle %u.\n", k);
      std::exit(1);
    }

    // only get triangles with some non-zero z component
    if (triangle.vertex1[2] != 0 || triangle.vertex2[2] != 0 || triangle.vertex3[2] != 0) {
      triangle_data.emplace_back(triangle);
    }
  }
  input.close();


  // write output
  std::ofstream output(output_path, std::ios::out | std::ios::binary);
  if (!output.is_open()) {
    fprintf(stderr, "Failed to open output.\n");
    std::exit(1);
  }

  // header
  output.write(header, 80);
  const uint32_t num_triangles_out = static_cast<uint32_t>(triangle_data.size());
  output.write(reinterpret_cast<const char*>(&num_triangles_out), 4);

  // triangles
  for (const stl_triangle &triangle : triangle_data) {
    output.write(reinterpret_cast<const char*>(&triangle), NUM_STL_TRIANGLE_BYTES);
  }
  output.close();
}

int32_t main(int32_t argc, char **argv) {
  std::string input_path;
  std::string output_path;
  ParseArgs(&input_path, &output_path, argc, argv);
  assert(input_path.size() != 0);
  assert(output_path.size() != 0);

  TrimTriangles(input_path, output_path);
}
